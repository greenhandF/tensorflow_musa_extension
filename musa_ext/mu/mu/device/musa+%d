#ifndef TENSORFLOW_MUSA_ALLOCATOR_H_
#define TENSORFLOW_MUSA_ALLOCATOR_H_

#include "tensorflow/core/framework/allocator.h"
#include <musa_runtime.h>
#include <string>
#include <algorithm> 

namespace tensorflow {
namespace musa {

class MusaRawAllocator : public Allocator {
 public:
  // 构造函数：必须记录该分配器绑定到哪张物理卡
  explicit MusaRawAllocator(int device_id) : device_id_(device_id) {}
  
  ~MusaRawAllocator() override = default;

  std::string Name() override { return "musa_raw_allocator"; }

  void* AllocateRaw(size_t alignment, size_t num_bytes) override {
    if (num_bytes == 0) return nullptr;

    // --- 【核心修复 1】 ---
    // 强制当前线程切换到该分配器所属的物理卡
    // 否则会在错误的卡上申请内存，导致 invalid device ordinal
    musaSetDevice(device_id_);

    // 1. 强制 256 字节对齐
    size_t target_alignment = std::max((size_t)256, alignment);

    // 2. 计算对齐后的大小
    size_t alloc_bytes = (num_bytes + target_alignment - 1) / target_alignment * target_alignment;

    // 3. 增加 256 字节 Padding (安全气囊)
    alloc_bytes += 256; 

    void* ptr = nullptr;
    if (musaMalloc(&ptr, alloc_bytes) != musaSuccess) {
        return nullptr;
    }
    
    return ptr;
  }

  void DeallocateRaw(void* ptr) override {
    if (ptr) {
      // --- 【核心修复 2】 ---
      // 释放内存时同样需要切换到正确的卡，否则 musaFree 会失败
      musaSetDevice(device_id_);
      musaFree(ptr);
    }
  }

 private:
  int device_id_; // 必须定义这个成员变量来存储卡号
};

} // namespace musa
} // namespace tensorflow
#endif
